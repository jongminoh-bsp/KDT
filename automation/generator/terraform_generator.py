#!/usr/bin/env python3
"""
Dynamic Terraform Code Generator
분석 결과를 기반으로 Terraform 코드를 자동 생성
"""

import json
import os
from pathlib import Path
from typing import Dict, List
from datetime import datetime

class TerraformGenerator:
    """Terraform 코드 생성기"""
    
    def __init__(self, analysis_result: Dict, config: Dict):
        self.analysis_result = analysis_result
        self.config = config
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def generate_all(self, output_dir: str = "terraform") -> Dict[str, str]:
        """모든 Terraform 파일 생성"""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        generated_files = {}
        
        # 메인 설정 파일
        generated_files["main.tf"] = self._generate_main_tf(output_path)
        generated_files["variables.tf"] = self._generate_variables_tf(output_path)
        generated_files["outputs.tf"] = self._generate_outputs_tf(output_path)
        
        # 모듈별 파일 생성
        modules_path = output_path / "modules"
        generated_files.update(self._generate_vpc_module(modules_path))
        generated_files.update(self._generate_eks_module(modules_path))
        
        if self.analysis_result['database']['required']:
            generated_files.update(self._generate_rds_module(modules_path))
        
        return generated_files
    
    def _generate_main_tf(self, output_path: Path) -> str:
        """메인 Terraform 파일 생성"""
        content = f'''# Generated by Amazon Q Terraform Generator
# Timestamp: {self.timestamp}
# Application: {self.analysis_result['framework']}

terraform {{
  required_version = ">= 1.0"
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}

provider "aws" {{
  region = var.aws_region
}}

# VPC Module
module "vpc" {{
  source = "./modules/vpc"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_cidr             = var.vpc_cidr
  availability_zones   = var.availability_zones
  public_subnet_cidrs  = var.public_subnet_cidrs
  private_subnet_cidrs = var.private_subnet_cidrs
}}

# EKS Module
module "eks" {{
  source = "./modules/eks"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id              = module.vpc.vpc_id
  private_subnet_ids  = module.vpc.private_subnet_ids
  
  node_instance_type = var.node_instance_type
  node_desired_size  = {self.analysis_result['resources']['replicas']}
  node_max_size      = {self.analysis_result['resources']['replicas'] + 2}
  node_min_size      = {max(1, self.analysis_result['resources']['replicas'] - 1)}
}}
'''

        if self.analysis_result['database']['required']:
            db_type = self.analysis_result['database']['type']
            content += f'''
# RDS Module
module "rds" {{
  source = "./modules/rds"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id             = module.vpc.vpc_id
  private_subnet_ids = module.vpc.private_subnet_ids
  
  engine         = "{db_type}"
  instance_class = var.db_instance_class
  allocated_storage = var.db_allocated_storage
  
  db_name     = var.db_name
  db_username = var.db_username
  db_password = var.db_password
}}
'''

        filepath = output_path / "main.tf"
        with open(filepath, 'w') as f:
            f.write(content)
        
        return str(filepath)
    
    def _generate_variables_tf(self, output_path: Path) -> str:
        """변수 파일 생성"""
        content = f'''# Terraform Variables
# Generated for {self.analysis_result['framework']} application

variable "aws_region" {{
  description = "AWS region"
  type        = string
  default     = "{self.config.get('AWS_REGION', 'ap-northeast-2')}"
}}

variable "project_name" {{
  description = "Project name"
  type        = string
  default     = "{self.config.get('PROJECT_NAME', 'skyline')}"
}}

variable "environment" {{
  description = "Environment name"
  type        = string
  default     = "{self.config.get('ENVIRONMENT', 'dev')}"
}}

# VPC Configuration
variable "vpc_cidr" {{
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}}

variable "availability_zones" {{
  description = "Availability zones"
  type        = list(string)
  default     = ["ap-northeast-2a", "ap-northeast-2b"]
}}

variable "public_subnet_cidrs" {{
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ["10.0.1.0/24", "10.0.2.0/24"]
}}

variable "private_subnet_cidrs" {{
  description = "CIDR blocks for private subnets"
  type        = list(string)
  default     = ["10.0.10.0/24", "10.0.11.0/24"]
}}

# EKS Configuration
variable "node_instance_type" {{
  description = "EC2 instance type for EKS nodes"
  type        = string
  default     = "{self._get_node_instance_type()}"
}}
'''

        if self.analysis_result['database']['required']:
            content += f'''
# RDS Configuration
variable "db_instance_class" {{
  description = "RDS instance class"
  type        = string
  default     = "db.t3.micro"
}}

variable "db_allocated_storage" {{
  description = "RDS allocated storage"
  type        = number
  default     = 20
}}

variable "db_name" {{
  description = "Database name"
  type        = string
  default     = "{self.config.get('PROJECT_NAME', 'skyline')}"
}}

variable "db_username" {{
  description = "Database username"
  type        = string
  default     = "admin"
}}

variable "db_password" {{
  description = "Database password"
  type        = string
  sensitive   = true
}}
'''

        filepath = output_path / "variables.tf"
        with open(filepath, 'w') as f:
            f.write(content)
        
        return str(filepath)
    
    def _generate_outputs_tf(self, output_path: Path) -> str:
        """출력 파일 생성"""
        content = '''# Terraform Outputs

output "vpc_id" {
  description = "VPC ID"
  value       = module.vpc.vpc_id
}

output "eks_cluster_name" {
  description = "EKS cluster name"
  value       = module.eks.cluster_name
}

output "eks_cluster_endpoint" {
  description = "EKS cluster endpoint"
  value       = module.eks.cluster_endpoint
}
'''

        if self.analysis_result['database']['required']:
            content += '''
output "rds_endpoint" {
  description = "RDS endpoint"
  value       = module.rds.endpoint
}

output "rds_port" {
  description = "RDS port"
  value       = module.rds.port
}
'''

        filepath = output_path / "outputs.tf"
        with open(filepath, 'w') as f:
            f.write(content)
        
        return str(filepath)
    
    def _get_node_instance_type(self) -> str:
        """노드 인스턴스 타입 결정"""
        memory_limit = self.analysis_result['resources']['memory_limit']
        
        if memory_limit == "2Gi":
            return "t3.medium"
        elif memory_limit == "1.5Gi":
            return "t3.small"
        else:
            return "t3.micro"
    
    def _generate_vpc_module(self, modules_path: Path) -> Dict[str, str]:
        """VPC 모듈 생성"""
        vpc_path = modules_path / "vpc"
        vpc_path.mkdir(parents=True, exist_ok=True)
        
        files = {}
        
        # VPC main.tf
        main_content = '''resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${var.project_name}-${var.environment}-vpc"
    Environment = var.environment
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name        = "${var.project_name}-${var.environment}-igw"
    Environment = var.environment
  }
}

resource "aws_subnet" "public" {
  count = length(var.public_subnet_cidrs)

  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnet_cidrs[count.index]
  availability_zone       = var.availability_zones[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name        = "${var.project_name}-${var.environment}-public-${count.index + 1}"
    Environment = var.environment
    Type        = "public"
  }
}

resource "aws_subnet" "private" {
  count = length(var.private_subnet_cidrs)

  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]

  tags = {
    Name        = "${var.project_name}-${var.environment}-private-${count.index + 1}"
    Environment = var.environment
    Type        = "private"
  }
}

resource "aws_eip" "nat" {
  count = length(var.public_subnet_cidrs)

  domain = "vpc"
  depends_on = [aws_internet_gateway.main]

  tags = {
    Name        = "${var.project_name}-${var.environment}-eip-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_nat_gateway" "main" {
  count = length(var.public_subnet_cidrs)

  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id

  tags = {
    Name        = "${var.project_name}-${var.environment}-nat-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-public-rt"
    Environment = var.environment
  }
}

resource "aws_route_table" "private" {
  count = length(var.private_subnet_cidrs)

  vpc_id = aws_vpc.main.id

  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.main[count.index].id
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-private-rt-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_route_table_association" "public" {
  count = length(var.public_subnet_cidrs)

  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table_association" "private" {
  count = length(var.private_subnet_cidrs)

  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[count.index].id
}
'''
        
        files[str(vpc_path / "main.tf")] = self._write_file(vpc_path / "main.tf", main_content)
        
        return files
    
    def _generate_eks_module(self, modules_path: Path) -> Dict[str, str]:
        """EKS 모듈 생성"""
        eks_path = modules_path / "eks"
        eks_path.mkdir(parents=True, exist_ok=True)
        
        files = {}
        
        # EKS main.tf (간단 버전)
        main_content = f'''# EKS Cluster
resource "aws_eks_cluster" "main" {{
  name     = "${{var.project_name}}-${{var.environment}}-cluster"
  role_arn = aws_iam_role.cluster.arn
  version  = "1.27"

  vpc_config {{
    subnet_ids = var.private_subnet_ids
  }}

  depends_on = [
    aws_iam_role_policy_attachment.cluster_AmazonEKSClusterPolicy,
  ]

  tags = {{
    Name        = "${{var.project_name}}-${{var.environment}}-cluster"
    Environment = var.environment
  }}
}}

# EKS Node Group
resource "aws_eks_node_group" "main" {{
  cluster_name    = aws_eks_cluster.main.name
  node_group_name = "${{var.project_name}}-${{var.environment}}-nodes"
  node_role_arn   = aws_iam_role.node.arn
  subnet_ids      = var.private_subnet_ids
  instance_types  = [var.node_instance_type]

  scaling_config {{
    desired_size = var.node_desired_size
    max_size     = var.node_max_size
    min_size     = var.node_min_size
  }}

  depends_on = [
    aws_iam_role_policy_attachment.node_AmazonEKSWorkerNodePolicy,
    aws_iam_role_policy_attachment.node_AmazonEKS_CNI_Policy,
    aws_iam_role_policy_attachment.node_AmazonEC2ContainerRegistryReadOnly,
  ]

  tags = {{
    Name        = "${{var.project_name}}-${{var.environment}}-nodes"
    Environment = var.environment
  }}
}}

# IAM Roles (simplified)
resource "aws_iam_role" "cluster" {{
  name = "${{var.project_name}}-${{var.environment}}-cluster-role"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "eks.amazonaws.com"
        }}
      }},
    ]
  }})
}}

resource "aws_iam_role_policy_attachment" "cluster_AmazonEKSClusterPolicy" {{
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.cluster.name
}}

resource "aws_iam_role" "node" {{
  name = "${{var.project_name}}-${{var.environment}}-node-role"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "ec2.amazonaws.com"
        }}
      }},
    ]
  }})
}}

resource "aws_iam_role_policy_attachment" "node_AmazonEKSWorkerNodePolicy" {{
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
  role       = aws_iam_role.node.name
}}

resource "aws_iam_role_policy_attachment" "node_AmazonEKS_CNI_Policy" {{
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
  role       = aws_iam_role.node.name
}}

resource "aws_iam_role_policy_attachment" "node_AmazonEC2ContainerRegistryReadOnly" {{
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
  role       = aws_iam_role.node.name
}}
'''
        
        files[str(eks_path / "main.tf")] = self._write_file(eks_path / "main.tf", main_content)
        
        return files
    
    def _generate_rds_module(self, modules_path: Path) -> Dict[str, str]:
        """RDS 모듈 생성"""
        if not self.analysis_result['database']['required']:
            return {}
        
        rds_path = modules_path / "rds"
        rds_path.mkdir(parents=True, exist_ok=True)
        
        files = {}
        
        db_type = self.analysis_result['database']['type']
        
        main_content = f'''# RDS Subnet Group
resource "aws_db_subnet_group" "main" {{
  name       = "${{var.project_name}}-${{var.environment}}-db-subnet-group"
  subnet_ids = var.private_subnet_ids

  tags = {{
    Name        = "${{var.project_name}}-${{var.environment}}-db-subnet-group"
    Environment = var.environment
  }}
}}

# RDS Security Group
resource "aws_security_group" "rds" {{
  name        = "${{var.project_name}}-${{var.environment}}-rds-sg"
  description = "Security group for RDS"
  vpc_id      = var.vpc_id

  ingress {{
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
  }}

  egress {{
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }}

  tags = {{
    Name        = "${{var.project_name}}-${{var.environment}}-rds-sg"
    Environment = var.environment
  }}
}}

# RDS Instance
resource "aws_db_instance" "main" {{
  identifier = "${{var.project_name}}-${{var.environment}}-db"

  engine         = var.engine
  engine_version = "{self._get_db_version(db_type)}"
  instance_class = var.instance_class

  allocated_storage     = var.allocated_storage
  max_allocated_storage = var.allocated_storage * 2

  db_name  = var.db_name
  username = var.db_username
  password = var.db_password

  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name

  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"

  skip_final_snapshot = true
  deletion_protection = false

  tags = {{
    Name        = "${{var.project_name}}-${{var.environment}}-db"
    Environment = var.environment
  }}
}}
'''
        
        files[str(rds_path / "main.tf")] = self._write_file(rds_path / "main.tf", main_content)
        
        return files
    
    def _get_db_version(self, db_type: str) -> str:
        """데이터베이스 버전 반환"""
        versions = {
            "mysql": "8.0",
            "postgresql": "15.3",
            "oracle": "19.0.0.0.ru-2023-04.rur-2023-04.r1"
        }
        return versions.get(db_type, "8.0")
    
    def _write_file(self, filepath: Path, content: str) -> str:
        """파일 작성"""
        with open(filepath, 'w') as f:
            f.write(content)
        return str(filepath)

def main():
    """테스트 실행"""
    # 샘플 분석 결과
    sample_analysis = {
        "framework": "spring-boot",
        "database": {"required": True, "type": "mysql"},
        "resources": {"replicas": 3, "memory_limit": "2Gi"}
    }
    
    sample_config = {
        "AWS_REGION": "ap-northeast-2",
        "PROJECT_NAME": "skyline",
        "ENVIRONMENT": "dev"
    }
    
    generator = TerraformGenerator(sample_analysis, sample_config)
    files = generator.generate_all("./generated_terraform")
    
    print("🚀 Generated Terraform files:")
    for file_path in files.values():
        print(f"  ✅ {file_path}")

if __name__ == "__main__":
    main()
