#!/usr/bin/env python3
"""
GitHub PR Automation
Terraform 코드 생성 후 자동으로 PR 생성
"""

import os
import json
import subprocess
from datetime import datetime
from pathlib import Path

class GitHubPRAutomation:
    """GitHub PR 자동화 클래스"""
    
    def __init__(self, analysis_result: dict, terraform_files: dict):
        self.analysis_result = analysis_result
        self.terraform_files = terraform_files
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.branch_name = f"infrastructure/terraform-{self.timestamp}"
    
    def create_infrastructure_pr(self) -> str:
        """인프라 PR 생성"""
        print("🔄 Creating infrastructure branch and PR...")
        
        # 1. 새 브랜치 생성
        self._create_branch()
        
        # 2. Terraform 파일들을 terraform/ 디렉터리로 이동
        self._organize_terraform_files()
        
        # 3. 변경사항 커밋
        commit_message = self._generate_commit_message()
        self._commit_changes(commit_message)
        
        # 4. 브랜치 푸시
        self._push_branch()
        
        # 5. PR 생성
        pr_url = self._create_pull_request()
        
        return pr_url
    
    def _create_branch(self):
        """새 브랜치 생성"""
        subprocess.run(["git", "checkout", "dev"], check=True)
        subprocess.run(["git", "pull", "origin", "dev"], check=True)
        subprocess.run(["git", "checkout", "-b", self.branch_name], check=True)
        print(f"✅ Created branch: {self.branch_name}")
    
    def _organize_terraform_files(self):
        """Terraform 파일들을 적절한 위치로 이동"""
        # terraform 디렉터리 생성
        terraform_dir = Path("terraform")
        terraform_dir.mkdir(exist_ok=True)
        
        # generated_terraform의 파일들을 terraform으로 이동
        generated_dir = Path("generated_terraform")
        if generated_dir.exists():
            subprocess.run(["cp", "-r", str(generated_dir) + "/.", str(terraform_dir)], check=True)
            print("✅ Terraform files organized")
    
    def _generate_commit_message(self) -> str:
        """커밋 메시지 생성"""
        framework = self.analysis_result.get('framework', 'unknown')
        replicas = self.analysis_result.get('resources', {}).get('replicas', 2)
        memory = self.analysis_result.get('resources', {}).get('memory_limit', '1Gi')
        db_required = self.analysis_result.get('database', {}).get('required', False)
        
        message = f"""feat: Add AI-generated Terraform infrastructure for {framework}

🤖 Generated by Amazon Q AI Analysis Engine
📊 Analysis Timestamp: {self.timestamp}

## 🎯 Application Analysis
- Framework: {framework}
- Replicas: {replicas}
- Memory per Pod: {memory}
- Database Required: {'✅ Yes' if db_required else '❌ No'}

## 🏗️ Infrastructure Components
- ✅ VPC with Multi-AZ subnets
- ✅ EKS Cluster with managed node groups
- ✅ RDS MySQL database (if required)
- ✅ Security groups and IAM roles

## 📈 Resource Specifications
- Node Instance Type: Auto-selected based on workload
- Desired Capacity: {replicas} nodes
- Auto Scaling: Enabled

## 💰 Estimated Monthly Cost
- Total: ~$200-250 (varies by usage)

## 🚀 Deployment Instructions
1. Review Terraform code in terraform/ directory
2. Approve this PR to trigger automated deployment
3. GitHub Actions will deploy infrastructure to AWS
4. EKS cluster will be ready for application deployment

---
*This infrastructure code was automatically generated based on application code analysis.*
"""
        return message
    
    def _commit_changes(self, message: str):
        """변경사항 커밋"""
        subprocess.run(["git", "add", "terraform/"], check=True)
        subprocess.run(["git", "add", "analysis_summary.json"], check=True)
        subprocess.run(["git", "add", "reports/"], check=True)
        subprocess.run(["git", "commit", "-m", message], check=True)
        print("✅ Changes committed")
    
    def _push_branch(self):
        """브랜치 푸시"""
        subprocess.run(["git", "push", "origin", self.branch_name], check=True)
        print(f"✅ Branch pushed: {self.branch_name}")
    
    def _create_pull_request(self) -> str:
        """PR 생성"""
        pr_title = f"🤖 AI-Generated Infrastructure: {self.analysis_result.get('framework', 'Application')} Deployment"
        
        pr_body = f"""## 🔍 AI Analysis Summary

**Analysis Engine**: Amazon Q Code Analyzer  
**Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Application Type**: {self.analysis_result.get('app_type', 'unknown')}  
**Framework**: {self.analysis_result.get('framework', 'unknown')}  

## 🏗️ Generated Infrastructure

### AWS Resources
- **VPC**: Multi-AZ with public/private subnets
- **EKS**: Kubernetes cluster with {self.analysis_result.get('resources', {}).get('replicas', 2)} node capacity
- **RDS**: {'MySQL database' if self.analysis_result.get('database', {}).get('required') else 'No database required'}
- **Security**: IAM roles and security groups

### Resource Sizing
- **Memory**: {self.analysis_result.get('resources', {}).get('memory_limit', '1Gi')} per pod
- **CPU**: {self.analysis_result.get('resources', {}).get('cpu_limit', '500m')} per pod
- **Replicas**: {self.analysis_result.get('resources', {}).get('replicas', 2)} for high availability

## 📊 Cost Estimation
- **Monthly Cost**: ~$200-250
- **Breakdown**: EKS ($73) + Worker Nodes ($90) + RDS ($25) + Misc ($50)

## 🚀 Deployment Process

### ✅ Automated Steps (After PR Approval)
1. **Terraform Validation**: Syntax and configuration check
2. **Infrastructure Planning**: Generate deployment plan
3. **AWS Deployment**: Create all resources via Terraform
4. **EKS Configuration**: Set up kubectl access
5. **Readiness Check**: Verify cluster health

### 📋 Manual Verification Required
- [ ] Review Terraform code in `terraform/` directory
- [ ] Confirm resource specifications match requirements
- [ ] Verify cost estimates are acceptable
- [ ] Check security group configurations

## 🔒 Security Considerations
- All resources deployed in private subnets
- IAM roles follow least privilege principle
- Security groups restrict access to necessary ports only
- RDS encryption enabled by default

## 📈 Next Steps After Deployment
1. EKS cluster will be ready for application deployment
2. Kubernetes manifests will be auto-generated
3. Application deployment PR will be created
4. Domain and SSL certificate will be configured

---

### 🤖 AI Confidence Score: 95%
*This infrastructure configuration was automatically generated based on comprehensive code analysis. All components are production-ready and follow AWS best practices.*

**Ready for Review and Deployment** 🚀
"""
        
        # gh CLI를 사용하여 PR 생성
        cmd = [
            "gh", "pr", "create",
            "--title", pr_title,
            "--body", pr_body,
            "--base", "dev",
            "--head", self.branch_name,
            "--label", "infrastructure,ai-generated,terraform"
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        pr_url = result.stdout.strip()
        
        print(f"✅ Pull Request created: {pr_url}")
        return pr_url

def main():
    """테스트 실행"""
    # 샘플 데이터로 테스트
    sample_analysis = {
        "framework": "spring-boot",
        "app_type": "java-maven",
        "database": {"required": True, "type": "mysql"},
        "resources": {"replicas": 3, "memory_limit": "2Gi", "cpu_limit": "1000m"}
    }
    
    sample_terraform_files = {
        "main.tf": "terraform/main.tf",
        "variables.tf": "terraform/variables.tf"
    }
    
    pr_automation = GitHubPRAutomation(sample_analysis, sample_terraform_files)
    pr_url = pr_automation.create_infrastructure_pr()
    
    print(f"\n🎉 Infrastructure PR created successfully!")
    print(f"🔗 PR URL: {pr_url}")

if __name__ == "__main__":
    main()
