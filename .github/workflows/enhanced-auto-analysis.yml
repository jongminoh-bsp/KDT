name: 🤖 Enhanced Auto AI Analysis (Full Directory Support)

on:
  push:
    branches: [dev]
    paths: 
      # 개별 애플리케이션 파일들
      - 'src/**'
      - 'pom.xml'
      - 'package.json'
      - 'requirements.txt'
      - 'build.gradle'
      - 'Dockerfile'
      # 전체 애플리케이션 디렉터리들
      - 'skyline_system_demo/**'
      - 'application/**'
      - 'app/**'
      - 'backend/**'
      - 'frontend/**'
      - '**/pom.xml'
      - '**/package.json'
      - '**/requirements.txt'

jobs:
  detect-and-analyze:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    outputs:
      has_apps: ${{ steps.detect.outputs.has_apps }}
      main_app: ${{ steps.detect.outputs.main_app }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: 🔍 Smart Application Detection
      id: detect
      run: |
        echo "🔍 Scanning for application code..."
        
        APP_DIRS=""
        
        # 1. skyline_system_demo 우선 확인
        if [ -d "skyline_system_demo" ]; then
          echo "✅ Found skyline_system_demo directory"
          APP_DIRS="skyline_system_demo"
        fi
        
        # 2. 루트 레벨 애플리케이션 파일들
        if [ -f "pom.xml" ] || [ -f "package.json" ] || [ -f "requirements.txt" ]; then
          echo "✅ Root level application detected"
          APP_DIRS="$APP_DIRS ./"
        fi
        
        # 3. 일반적인 애플리케이션 디렉터리들
        for dir in application app backend frontend src; do
          if [ -d "$dir" ]; then
            if [ -f "$dir/pom.xml" ] || [ -f "$dir/package.json" ] || [ -f "$dir/requirements.txt" ]; then
              echo "✅ Application found in: $dir"
              APP_DIRS="$APP_DIRS $dir"
            fi
          fi
        done
        
        # 4. 소스 코드가 있는 디렉터리 찾기
        find . -maxdepth 2 -name "*.java" -o -name "*.js" -o -name "*.py" | head -5 | while read file; do
          dir=$(dirname "$file")
          if [ "$dir" != "." ] && [[ ! "$APP_DIRS" == *"$dir"* ]]; then
            echo "✅ Source code found in: $dir"
            APP_DIRS="$APP_DIRS $dir"
          fi
        done
        
        # 중복 제거 및 정리
        APP_DIRS=$(echo $APP_DIRS | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
        
        echo "📋 Detected directories: $APP_DIRS"
        
        # 메인 애플리케이션 선택 (우선순위: skyline > 첫 번째)
        MAIN_APP=""
        for app_dir in $APP_DIRS; do
          if [[ "$app_dir" == *"skyline"* ]]; then
            MAIN_APP="$app_dir"
            break
          fi
        done
        
        if [ -z "$MAIN_APP" ] && [ -n "$APP_DIRS" ]; then
          MAIN_APP=$(echo "$APP_DIRS" | awk '{print $1}')
        fi
        
        if [ -n "$MAIN_APP" ]; then
          echo "🎯 Main application: $MAIN_APP"
          echo "has_apps=true" >> $GITHUB_OUTPUT
          echo "main_app=$MAIN_APP" >> $GITHUB_OUTPUT
        else
          echo "❌ No application code detected"
          echo "has_apps=false" >> $GITHUB_OUTPUT
        fi
    
    - name: 🤖 Run AI Analysis
      if: steps.detect.outputs.has_apps == 'true'
      run: |
        MAIN_APP="${{ steps.detect.outputs.main_app }}"
        echo "🤖 Analyzing application: $MAIN_APP"
        
        # 절대 경로 생성
        if [ "$MAIN_APP" = "./" ]; then
          ANALYSIS_PATH="$(pwd)"
        else
          ANALYSIS_PATH="$(pwd)/$MAIN_APP"
        fi
        
        echo "📍 Analysis path: $ANALYSIS_PATH"
        
        # AI 분석 실행
        python3 automation/analyzer/code_analyzer.py "$ANALYSIS_PATH" > analysis_output.txt
        
        echo "📊 Analysis Results:"
        cat analysis_output.txt
        
        # 분석 결과를 환경변수로 저장
        echo "ANALYSIS_PATH=$ANALYSIS_PATH" >> $GITHUB_ENV
    
    - name: 🏗️ Generate Infrastructure
      if: steps.detect.outputs.has_apps == 'true'
      run: |
        echo "🏗️ Generating Terraform infrastructure..."
        
        # config.py 업데이트
        sed -i "s|APPLICATION_SOURCE_PATH = \".*\"|APPLICATION_SOURCE_PATH = \"$ANALYSIS_PATH\"|" automation/config.py
        
        # 전체 파이프라인 실행 (PR 생성 제외)
        python3 -c "
import sys, os
sys.path.append('automation')
os.chdir('$(pwd)')

from analyzer.code_analyzer import ApplicationAnalyzer
from analyzer.report_generator import AnalysisReportGenerator  
from generator.terraform_generator import TerraformGenerator
import config
import json

print('🔍 Analyzing:', config.APPLICATION_SOURCE_PATH)
analyzer = ApplicationAnalyzer(config.APPLICATION_SOURCE_PATH)
result = analyzer.analyze()

print('📊 Generating report...')
os.makedirs('reports', exist_ok=True)
report_gen = AnalysisReportGenerator(result, config.APPLICATION_SOURCE_PATH)
report_file = report_gen.save_report('./reports')

summary = report_gen.generate_json_summary()
with open('analysis_summary.json', 'w') as f:
    json.dump(summary, f, indent=2)

print('🏗️ Generating Terraform...')
terraform_config = {
    'AWS_REGION': getattr(config, 'AWS_REGION', 'ap-northeast-2'),
    'PROJECT_NAME': getattr(config, 'PROJECT_NAME', 'skyline'),
    'ENVIRONMENT': getattr(config, 'ENVIRONMENT', 'dev'),
    'ECR_IMAGE_URI': getattr(config, 'ECR_IMAGE_URI', '646558765106.dkr.ecr.ap-northeast-2.amazonaws.com/skyline-dev:latest'),
    'DOMAIN_NAME': getattr(config, 'DOMAIN_NAME', 'www.greenbespinglobal.store')
}

terraform_gen = TerraformGenerator(result, terraform_config)
terraform_files = terraform_gen.generate_all('./generated_terraform')

print('✅ Generation complete!')
print(f'📱 Framework: {result[\"framework\"]}')
print(f'🔄 Replicas: {result[\"resources\"][\"replicas\"]}')
print(f'💾 Memory: {result[\"resources\"][\"memory_limit\"]}')
"
    
    - name: 🔄 Create Auto PR
      if: steps.detect.outputs.has_apps == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        MAIN_APP="${{ steps.detect.outputs.main_app }}"
        
        # Git 설정
        git config --global user.name "Amazon Q AI"
        git config --global user.email "ai@amazonq.aws"
        
        # 브랜치 생성
        BRANCH_NAME="auto-infra/$(echo $MAIN_APP | tr '/' '-')-$(date +%Y%m%d_%H%M%S)"
        git checkout -b $BRANCH_NAME
        
        # Terraform 파일 정리
        mkdir -p terraform
        if [ -d "generated_terraform" ]; then
          cp -r generated_terraform/* terraform/ 2>/dev/null || true
        fi
        
        # 변경사항 커밋
        git add terraform/ reports/ analysis_summary.json automation/config.py 2>/dev/null || true
        git commit -m "🤖 Auto-Infrastructure: $MAIN_APP

📱 Application: $MAIN_APP
🔍 Auto-detected and analyzed
🏗️ Generated Terraform infrastructure
🚀 Ready for deployment

Generated by Amazon Q AI Engine
Timestamp: $(date)" || echo "No changes to commit"
        
        # 브랜치 푸시
        git push origin $BRANCH_NAME
        
        # PR 생성
        gh pr create \
          --title "🤖 Auto-Infrastructure: $(basename $MAIN_APP)" \
          --body "## 🔍 Automatic Application Detection

**Detected Application**: \`$MAIN_APP\`  
**Detection Time**: $(date)  
**AI Engine**: Amazon Q Code Analyzer  

### 📊 What Happened
1. **Code Push Detected** → Application directory identified
2. **AI Analysis** → Code structure and dependencies analyzed  
3. **Infrastructure Generated** → Terraform code created automatically
4. **PR Created** → This pull request generated for review

### 🏗️ Generated Infrastructure
- **VPC**: Multi-AZ networking setup
- **EKS**: Kubernetes cluster (auto-sized)
- **RDS**: Database (if required by application)
- **Security**: IAM roles and security groups

### 🎯 Application Analysis Results
- **Type**: Auto-detected from code structure
- **Framework**: Identified via file analysis
- **Resources**: Optimized based on complexity
- **Dependencies**: External services catalogued

### 🚀 Next Steps
1. **Review** the generated Terraform in \`terraform/\` directory
2. **Approve** this PR to trigger infrastructure deployment
3. **GitHub Actions** will deploy everything automatically
4. **EKS cluster** will be ready for your application

### 📋 Files Generated
- \`terraform/main.tf\` - Main infrastructure configuration
- \`terraform/modules/\` - Modular resource definitions
- \`reports/\` - Detailed analysis report
- \`analysis_summary.json\` - Machine-readable summary

**This PR was created automatically by Amazon Q AI!** 🤖

**Ready for review and deployment!** ✅" \
          --base dev \
          --head $BRANCH_NAME \
          --label "ai-generated,auto-detected,infrastructure"

  # 애플리케이션이 감지되지 않은 경우 알림
  no-apps-found:
    if: always() && needs.detect-and-analyze.outputs.has_apps != 'true'
    runs-on: ubuntu-latest
    needs: detect-and-analyze
    
    steps:
    - name: 📝 No Applications Detected
      run: |
        echo "ℹ️ No application code detected in this push"
        echo ""
        echo "🔍 Amazon Q AI looks for:"
        echo "  📁 Directories: skyline_system_demo/, application/, app/, backend/, frontend/, src/"
        echo "  📄 Files: pom.xml, package.json, requirements.txt, build.gradle"
        echo "  💻 Source: .java, .js, .py, .ts files"
        echo ""
        echo "💡 To trigger AI analysis, push:"
        echo "  - Complete application directory (like skyline_system_demo/)"
        echo "  - Individual application files to supported paths"
        echo ""
        echo "🤖 Amazon Q AI will automatically detect and analyze your code!"
